---
alwaysApply: true
---

# Storion - AI Coding Rules

This project uses **Storion**, a reactive state management library for React.
For detailed documentation, see `packages/storion/README.md` and `packages/storion/AI_GUIDE.md`.

## Naming Conventions

- Store specs: `xxxStore` (e.g., `userStore`, `cartStore`)
- Service factories: `xxxService` (e.g., `apiService`, `loggerService`)
- Mixins: `xxxMixin` (e.g., `counterMixin`)
- Async actions:
  - Queries (read): `xxxQuery` (e.g., `userQuery`, `postsQuery`)
  - Mutations (write): `xxxMutation` (e.g., `createUserMutation`, `updatePostMutation`)
- Meta types:
  - Boolean flags: adjectives/past participles (`persisted`, `deprecated`, `hidden`)
  - Exclusions: `not` + adjective (`notPersisted`, `notLogged`)
  - Storage targets: `in` + storage (`inSession`, `inLocal`, `inCloud`)
  - Validation: verb/noun (`validate`, `minLength`, `pattern`)
  - Config values: noun (`priority`, `debounce`, `ttl`)
  - Features: `with` + feature or `-able` suffix (`withDevtools`, `loggable`)

## Imports

**For React apps** - import everything from `storion/react` (it re-exports from `storion`):

```ts
import {
  store,
  container,
  effect,
  pick,
  trigger,
  useStore,
  StoreProvider,
} from "storion/react";
import { async } from "storion/async";
```

**For non-React apps:**

```ts
import { store, container, effect, pick, trigger } from "storion";
import { async } from "storion/async";
```

## Critical Rules

### 1. Direct Mutation: First-Level Only

```ts
// ✅ CORRECT
state.count = 10;

// ❌ WRONG - nested (won't trigger reactivity)
state.profile.name = "John";

// ✅ CORRECT - use update() for nested
update((draft) => {
  draft.profile.name = "John";
});
```

### 2. get() is Setup-Time Only

```ts
// ✅ CORRECT
setup({ get }) {
  const [otherState, otherActions] = get(otherStore);
  return {
    doSomething: () => { /* use otherState here */ },
  };
}

// ❌ WRONG - get() inside action throws
setup({ get }) {
  return {
    doSomething: () => { get(otherStore); }, // THROWS!
  };
}
```

### 3. Effects Must Be Synchronous

```ts
// ❌ WRONG
effect(async (ctx) => {
  await fetchData();
});

// ✅ CORRECT
effect((ctx) => {
  ctx.safe(fetchData()).then((data) => {
    state.data = data;
  });
});
```

### 3b. Effect Cleanup: Use ctx.onCleanup()

```ts
// ❌ WRONG - returning cleanup function (not React useEffect!)
effect(() => {
  const handler = () => {};
  document.addEventListener("click", handler);
  return () => document.removeEventListener("click", handler);
});

// ✅ CORRECT - use ctx.onCleanup()
effect((ctx) => {
  const handler = () => {};
  document.addEventListener("click", handler);
  ctx.onCleanup(() => document.removeEventListener("click", handler));
});
```

### 4. trigger() is Global Function

```ts
import { trigger } from "storion/react";

// ✅ CORRECT
trigger(actions.fetch, [userId], userId);

// ❌ WRONG - anonymous function
trigger(() => actions.fetch(userId), [userId]);
```

### 5. async.wait() Behavior

| Status    | Fresh Mode                   | Stale Mode            |
| --------- | ---------------------------- | --------------------- |
| `idle`    | ❌ Throws AsyncNotReadyError | ✅ Returns stale data |
| `pending` | ❌ Throws promise (Suspense) | ✅ Returns stale data |
| `success` | ✅ Returns data              | ✅ Returns data       |
| `error`   | ❌ Throws error              | ✅ Returns stale data |

### 6. Store Lifetime

```ts
// ❌ WRONG - keepAlive cannot depend on autoDispose
const shortLived = store({ lifetime: "autoDispose", ... });
const longLived = store({
  lifetime: "keepAlive",
  setup: ({ get }) => { get(shortLived); }, // THROWS!
});
```

### 7. Meta: Store-Level vs Field-Level

**Meta overloads:**

- `meta()` → `myMeta()` returns `boolean` (true)
- `meta<TValue>()` → `myMeta(value: TValue)` returns `TValue`
- `meta(builder)` → custom transformation

**Usage:**

- `myMeta()` or `myMeta(value)` for store-level meta
- `myMeta.for("field")` or `myMeta.for("field", value)` for single field
- `myMeta.for(["f1", "f2"])` for multiple fields

```ts
import { meta } from "storion";

// Boolean flag meta - myMeta() returns true
const persist = meta();

// Typed value meta - myMeta(value) returns the value
const priority = meta<number>();

// Custom builder meta
const validate = meta((rule: string) => rule);

const userStore = store({
  name: "user",
  state: { name: "", password: "", token: "" },
  meta: [
    persist(), // ✅ store-level (value: true)
    priority(1), // ✅ store-level (value: 1)
    persist.for("name"), // ✅ single field (value: true)
    persist.for(["password", "token"]), // ✅ multiple fields (value: true)
    validate.for(["email", "phone"], "required"), // ✅ multiple fields with value
  ],
});

// ❌ WRONG - don't pass field name as argument to flag meta
meta: [persist("password")]; // This passes "password" as VALUE, not field!
```

### 8. Store Type Inference and Documentation

**Don't pass explicit generics to store()** - let TypeScript infer state and actions:

```ts
// ❌ WRONG - explicit generics
const userStore = store<UserState, UserActions>({
  name: "user",
  state: { name: "" },
  setup() {
    return { setName: (n: string) => {} };
  },
});

// ✅ CORRECT - let TypeScript infer
const userStore = store({
  name: "user",
  state: { name: "" },
  setup() {
    return { setName: (n: string) => {} };
  },
});
```

**Put JSDoc comments inline** - document state props in state object, actions in return object:

```ts
// ❌ WRONG - separate interfaces
interface UserState {
  name: string;
}
interface UserActions {
  setName(n: string): void;
}

// ✅ CORRECT - inline documentation
const userStore = store({
  name: "user",
  state: {
    /** User's display name */
    name: "",
    /** User's age in years */
    age: 0,
  },
  setup({ state }) {
    return {
      /** Update the user's name */
      setName: (name: string) => {
        state.name = name;
      },
      /** Reset user to default values */
      reset: () => {
        state.name = "";
        state.age = 0;
      },
    };
  },
});
```

## Quick Patterns

### Define Store

```ts
const userStore = store({
  name: "user",
  state: {
    /** User's display name */
    name: "",
    /** User's age in years */
    age: 0,
  },
  setup({ state, update }) {
    return {
      /** Update the user's name */
      setName: (name: string) => {
        state.name = name;
      },
    };
  },
});
```

### Use in React

```tsx
function Component() {
  const { name, setName } = useStore(({ get }) => {
    const [state, actions] = get(userStore);
    return { name: state.name, setName: actions.setName };
  });
  return <input value={name} onChange={(e) => setName(e.target.value)} />;
}
```

### Component-Local Stores with scoped()

Use `scoped()` for stores that should be isolated to a component and auto-disposed on unmount:

```tsx
function FormComponent() {
  const { value, setValue } = useStore(({ get, scoped }) => {
    // Global stores via get()
    const [userState] = get(userStore);

    // Component-local stores via scoped() - auto-disposed on unmount
    const [formState, formActions, formInstance] = scoped(formStore);

    return {
      value: formState.value,
      setValue: formActions.setValue,
    };
  });

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

**Key points:**

- `scoped()` can only be called during selector execution (not in callbacks)
- Returns `[state, actions, instance]` tuple
- Each component gets its own isolated instance
- Instances are automatically disposed when component unmounts

### Async State (Store-bound)

```ts
const userStore = store({
  name: "user",
  state: {
    user: async.fresh<User>(), // undefined during loading
    users: async.stale<User[]>([]), // keeps previous data
  },
  setup({ focus }) {
    // Use *Query for read operations
    const userQuery = async(focus("user"), async (ctx, id: string) => {
      const res = await fetch(`/api/users/${id}`, { signal: ctx.signal });
      return res.json();
    });

    const usersQuery = async(focus("users"), async (ctx) => {
      const res = await fetch("/api/users", { signal: ctx.signal });
      return res.json();
    });

    return {
      fetchUser: userQuery.dispatch,
      fetchUsers: usersQuery.dispatch,
      refreshUsers: usersQuery.refresh,
    };
  },
});
```

### Async Mixin (Component-local mutations)

Use `async(handler)` without focus for component-local async state - ideal for form submissions and mutations:

```ts
import { async } from "storion/async";

// Use *Mutation for write operations
const submitFormMutation = async(async (ctx, data: FormData) => {
  const res = await fetch("/api/submit", {
    method: "POST",
    body: JSON.stringify(data),
    signal: ctx.signal,
  });
  return res.json();
});

// Use in component - state is component-local, auto-disposed
function ContactForm() {
  const { status, error, submit } = useStore(({ mixin }) => {
    const [state, actions] = mixin(submitFormMutation);
    return {
      status: state.status,
      error: state.error,
      submit: actions.dispatch,
    };
  });

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        submit(formData);
      }}
    >
      <button disabled={status === "pending"}>
        {status === "pending" ? "Submitting..." : "Submit"}
      </button>
      {status === "error" && <p>{error.message}</p>}
    </form>
  );
}

// Access other stores via ctx.get() for cross-store mutations
const checkoutMutation = async(async (ctx, paymentMethod: string) => {
  const [user] = ctx.get(userStore);
  const [cart] = ctx.get(cartStore);

  const res = await fetch("/api/checkout", {
    headers: { Authorization: `Bearer ${user.token}` },
    body: JSON.stringify({ items: cart.items, paymentMethod }),
    signal: ctx.signal,
  });
  return res.json();
});
```

**When to use:**

- `async(focus, handler)` → shared/cached data (queries) → name as `*Query`
- `async(handler)` → component-local (mutations, form submissions) → name as `*Mutation`
- `ctx.get(store)` → access other stores' state within mixin handler

### Abortable Functions

Use `abortable()` to create functions that receive `AbortSignal` automatically:

```ts
import { abortable } from "storion/async";

// Define abortable service methods (ctx has signal and safe)
const userService = {
  getUser: abortable(async ({ signal }, id: string) => {
    const res = await fetch(`/api/users/${id}`, { signal });
    return res.json();
  }),
};

// ✅ BEST: Pass directly to async() - signal auto-injected
const userQuery = async(focus("user"), userService.getUser);

// Also works: via ctx.safe()
const userQuery = async(focus("user"), (ctx, id: string) =>
  ctx.safe(userService.getUser, id)
);

// Direct call (creates new AbortController)
const user = await userService.getUser(id);

// Explicit signal
const user = await userService.getUser.withSignal(controller.signal, id);

// Chainable wrappers with use()
import { retry, catchError, timeout } from "storion/async";

const robustGetUser = userService.getUser
  .use(retry(3))
  .use(catchError(console.error))
  .use(timeout(5000));
```

### ctx.safe() Overloads

`ctx.safe()` has multiple overloads for effect and async contexts:

```ts
// 1. Wrap promise - never resolve/reject if cancelled
ctx.safe(fetchData());

// 2. Call function with args - wrap result if promise
ctx.safe(processData, arg1, arg2);

// 3. Call abortable function - auto-inject signal
ctx.safe(userService.getUser, userId);
```

### Trigger Fetch

```tsx
function UserProfile({ userId }: { userId: string }) {
  const { user } = useStore(({ get }) => {
    const [state, actions] = get(userStore);
    trigger(actions.fetchUser, [userId], userId);
    return { user: state.user };
  });

  if (user.status === "pending") return <Spinner />;
  if (user.status === "error") return <Error error={user.error} />;
  return <div>{user.data?.name}</div>;
}
```

## Common Errors

| Error                        | Cause                       | Solution                    |
| ---------------------------- | --------------------------- | --------------------------- |
| `Cannot wait: state is idle` | async.wait() on fresh idle  | Call trigger/dispatch first |
| `Setup phase has ended`      | get/mixin/focus in action   | Move to setup phase         |
| `Effect must be synchronous` | async effect                | Use ctx.safe()              |
| `lifetime mismatch`          | keepAlive → autoDispose dep | Fix dependency direction    |
| `scoped() outside selector`  | scoped() in callback/async  | Move to selector body       |

## Testing

- Use `jest` with `it()` (not `test()`)
- Write tests first, then code, then run and fix

## GitHub Pages Demo Deployment

When deploying demos (SPAs) alongside VitePress docs to GitHub Pages, follow these rules to avoid navigation issues between docs and demos:

### 1. Demo App: Handle Back Navigation

Each demo SPA must handle browser back/forward navigation outside its base path:

```tsx
// In demo's main.tsx
const BASE_PATH = "/storion/demos/my-demo";

// Handle back/forward navigation
window.addEventListener("popstate", () => {
  if (!window.location.pathname.startsWith(BASE_PATH)) {
    // Navigated outside demo - do full page reload
    window.location.reload();
  }
});
```

### 2. Demo App: Vite Base Path

Configure Vite with the correct base path:

```ts
// vite.config.ts
export default defineConfig({
  base: "/storion/demos/my-demo/",
  // ...
});
```

### 3. Docs: Force Full Navigation to Demos

In VitePress, demo links must trigger full page navigation (not client-side routing):

```vue
<!-- In demos.md -->
<script setup>
import { onMounted } from "vue";

onMounted(() => {
  document.querySelectorAll('a[href*="/demos/"]').forEach((link) => {
    link.addEventListener("click", (e) => {
      e.preventDefault();
      window.location.href = link.getAttribute("href");
    });
  });
});
</script>
```

### 4. GitHub Actions: Add .nojekyll

Prevent Jekyll processing of the static site:

```yaml
# In .github/workflows/docs.yml
- name: Add .nojekyll file
  run: touch packages/docs/.vitepress/dist/.nojekyll
```

### 5. Demo Build Output

All demo builds should be copied to `packages/docs/.vitepress/dist/demos/`:

```yaml
# In .github/workflows/docs.yml
- name: Copy demo builds
  run: |
    mkdir -p packages/docs/.vitepress/dist/demos
    cp -r packages/my-demo/dist packages/docs/.vitepress/dist/demos/my-demo
```

### Why These Rules?

| Issue                      | Cause                         | Solution                        |
| -------------------------- | ----------------------------- | ------------------------------- |
| Back button doesn't work   | Demo SPA captures all routes  | `popstate` listener with reload |
| Demo doesn't load on click | VitePress client-side routing | Force `window.location.href`    |
| 404 on refresh             | GitHub Pages tries Jekyll     | Add `.nojekyll` file            |
| Styles broken              | Wrong asset paths             | Correct Vite `base` path        |

## Writing Documentation

Documentation lives in `packages/docs/`. Follow these conventions:

### Directory Structure

| Directory   | Content Type                                               |
| ----------- | ---------------------------------------------------------- |
| `guide/`    | Basic, essentials, and advanced examples with explanations |
| `api/`      | API reference with best practices and detailed signatures  |
| `examples/` | Standalone runnable examples                               |

### Linking Rules

**Always link API mentions** - When mentioning functions, methods, classes, or types in documentation, link to their corresponding `api/*` page:

```md
<!-- ✅ CORRECT - link to API reference -->

Use [`store()`](/api/store) to define reactive state.
The [`async()`](/api/async) function handles async operations.
Configure persistence with [`persist`](/api/persist-middleware) middleware.

<!-- ❌ WRONG - no link -->

Use `store()` to define reactive state.
```

### Content Guidelines

**`guide/` pages:**

- Start with basic concepts, progress to advanced usage
- Include practical examples with explanations
- Focus on "how to use" and "when to use"
- Link to `api/*` pages for detailed signatures and options

**`api/` pages:**

- Include complete function signatures and types
- Document all parameters and return values
- Add best practices and common pitfalls
- Include short, focused code examples

### Example Links

| Mention              | Link Path                 |
| -------------------- | ------------------------- |
| `store()`            | `/api/store`              |
| `async()`            | `/api/async`              |
| `abortable()`        | `/api/abortable`          |
| `effect()`           | `/api/effect`             |
| `trigger()`          | `/api/trigger`            |
| `useStore()`         | `/api/use-store`          |
| `meta()`             | `/api/meta`               |
| `container()`        | `/api/container`          |
| `StoreProvider`      | `/api/store-provider`     |
| `withStore()`        | `/api/with-store`         |
| `stable()`           | `/api/stable`             |
| `persist` middleware | `/api/persist-middleware` |

### VitePress Documentation Style

#### Page Structure

- **Title (H1)**: Brief noun phrase (e.g., "Getting Started", "Core Concepts")
- **Intro**: 1-2 sentences explaining what this covers and why it matters
- **Time estimate**: Add "**Time to read:** ~X minutes" for guides >5 min
- **Separators**: Use `---` between major conceptual sections

#### Section Patterns

- **Problem→Solution flow**: Use "### The Problem" → "### The Solution" pattern
- **Analogies**: Start sections with `> **Analogy:** ...` blockquote for complex concepts
- **Subsections**: Use "### What's Happening Here?" after code blocks to explain

#### Code Examples in Docs

- **Inline comments**: Explain each significant line with `// comment`
- **Wrong/Right contrast**: Use `// ❌ WRONG` and `// ✅ CORRECT` prefixes
- **Show progression**: First show the problem code, then the fix
- **Numbered lists in comments**: `// 1. First step` for multi-step explanations

#### VitePress Callouts

```md
::: tip Title - Helpful suggestions, best practices
::: info Title - Requirements, neutral information
::: warning Title - Important cautions, breaking behaviors
::: details Title - Expandable content for deeper info
:::
```

#### API Reference Format (in `/api/` pages)

```md
# functionName()

Brief one-line description.

## Signature

\`\`\`ts
function name<T>(args): ReturnType
\`\`\`

## Options

### optionName

Description.

- **Type:** `TypeHere`
- **Required:** Yes/No (default if No)

## Example

\`\`\`ts
// Practical usage
\`\`\`

## Return Value

Description of what's returned.
```

#### Tables & Diagrams

- **Tables**: Use for comparisons ("When to Use Which?"), feature matrices, type mappings
- **Mermaid `sequenceDiagram`**: For interaction flows
- **Mermaid `flowchart TB`**: For architecture overviews
- Add emoji icons in node labels for visual distinction

#### Writing Tone

- Second person: "you", "your app"
- Conversational: rhetorical questions ("What if you forget?")
- Explain WHY before HOW
- Use "**Fix:**" after explaining a problem

## JSDoc Style for Source Files

### File-Level Comment

```ts
/**
 * ModuleName - Brief one-line description.
 *
 * Additional context sentence(s) explaining purpose.
 * - Key feature 1
 * - Key feature 2
 */
```

### Section Separators

```ts
// =============================================================================
// SECTION NAME
// =============================================================================
```

### Type/Interface Documentation

````ts
/**
 * Brief description on first line.
 * Additional details if needed.
 *
 * @example
 * ```ts
 * // usage example
 * ```
 */
export type MyType = ...;

export interface MyInterface {
  /** Description of property */
  prop: string;
  /** Detailed description - can be multi-line */
  complex: number;
}
````

### Function Documentation

````ts
/**
 * Brief description of what the function does.
 *
 * ## Key Features (use markdown headers for sections)
 *
 * - Feature point
 * - Another point
 *
 * @example
 * ```tsx
 * // Basic usage
 * const result = myFunction(arg);
 * ```
 *
 * @example
 * ```tsx
 * // Advanced usage
 * const result = myFunction(arg, options);
 * ```
 */
````

### Grouped Examples with Headers

```ts
 * @example
 * // ============================================================
 * // PATTERN NAME (e.g., REUSABILITY PATTERNS)
 * // ============================================================
 *
 * // 1. First pattern
 * code...
 *
 * // 2. Second pattern
 * code...
```

### Inline Comments

- Use `// Note:` for important notes inline
- Use `// ===== Section Name =====` for minor subsections
- Keep helper functions brief: single-line JSDoc or inline comment
