---
alwaysApply: true
---

# Storion - AI Coding Rules

This project uses **Storion**, a reactive state management library for React.
For detailed documentation, see `packages/storion/README.md` and `packages/storion/AI_GUIDE.md`.

## Naming Conventions

- Store specs: `xxxStore` (e.g., `userStore`, `cartStore`)
- Service factories: `xxxService` (e.g., `apiService`, `loggerService`)
- Mixins: `xxxMixin` (e.g., `counterMixin`)
- Meta types:
  - Boolean flags: adjectives/past participles (`persisted`, `deprecated`, `hidden`)
  - Exclusions: `not` + adjective (`notPersisted`, `notLogged`)
  - Storage targets: `in` + storage (`inSession`, `inLocal`, `inCloud`)
  - Validation: verb/noun (`validate`, `minLength`, `pattern`)
  - Config values: noun (`priority`, `debounce`, `ttl`)
  - Features: `with` + feature or `-able` suffix (`withDevtools`, `loggable`)

## Imports

**For React apps** - import everything from `storion/react` (it re-exports from `storion`):

```ts
import {
  store,
  container,
  effect,
  pick,
  trigger,
  useStore,
  StoreProvider,
} from "storion/react";
import { async } from "storion/async";
```

**For non-React apps:**

```ts
import { store, container, effect, pick, trigger } from "storion";
import { async } from "storion/async";
```

## Critical Rules

### 1. Direct Mutation: First-Level Only

```ts
// ✅ CORRECT
state.count = 10;

// ❌ WRONG - nested (won't trigger reactivity)
state.profile.name = "John";

// ✅ CORRECT - use update() for nested
update((draft) => {
  draft.profile.name = "John";
});
```

### 2. get() is Setup-Time Only

```ts
// ✅ CORRECT
setup({ get }) {
  const [otherState, otherActions] = get(otherStore);
  return {
    doSomething: () => { /* use otherState here */ },
  };
}

// ❌ WRONG - get() inside action throws
setup({ get }) {
  return {
    doSomething: () => { get(otherStore); }, // THROWS!
  };
}
```

### 3. Effects Must Be Synchronous

```ts
// ❌ WRONG
effect(async (ctx) => {
  await fetchData();
});

// ✅ CORRECT
effect((ctx) => {
  ctx.safe(fetchData()).then((data) => {
    state.data = data;
  });
});
```

### 3b. Effect Cleanup: Use ctx.onCleanup()

```ts
// ❌ WRONG - returning cleanup function (not React useEffect!)
effect(() => {
  const handler = () => {};
  document.addEventListener("click", handler);
  return () => document.removeEventListener("click", handler);
});

// ✅ CORRECT - use ctx.onCleanup()
effect((ctx) => {
  const handler = () => {};
  document.addEventListener("click", handler);
  ctx.onCleanup(() => document.removeEventListener("click", handler));
});
```

### 4. trigger() is Global Function

```ts
import { trigger } from "storion/react";

// ✅ CORRECT
trigger(actions.fetch, [userId], userId);

// ❌ WRONG - anonymous function
trigger(() => actions.fetch(userId), [userId]);
```

### 5. async.wait() Behavior

| Status    | Fresh Mode                   | Stale Mode            |
| --------- | ---------------------------- | --------------------- |
| `idle`    | ❌ Throws AsyncNotReadyError | ✅ Returns stale data |
| `pending` | ❌ Throws promise (Suspense) | ✅ Returns stale data |
| `success` | ✅ Returns data              | ✅ Returns data       |
| `error`   | ❌ Throws error              | ✅ Returns stale data |

### 6. Store Lifetime

```ts
// ❌ WRONG - keepAlive cannot depend on autoDispose
const shortLived = store({ lifetime: "autoDispose", ... });
const longLived = store({
  lifetime: "keepAlive",
  setup: ({ get }) => { get(shortLived); }, // THROWS!
});
```

### 7. Meta: Store-Level vs Field-Level

**Meta overloads:**
- `meta()` → `myMeta()` returns `boolean` (true)
- `meta<TValue>()` → `myMeta(value: TValue)` returns `TValue`
- `meta(builder)` → custom transformation

**Usage:**
- `myMeta()` or `myMeta(value)` for store-level meta
- `myMeta.for("field")` or `myMeta.for("field", value)` for single field
- `myMeta.for(["f1", "f2"])` for multiple fields

```ts
import { meta } from "storion";

// Boolean flag meta - myMeta() returns true
const persist = meta();

// Typed value meta - myMeta(value) returns the value
const priority = meta<number>();

// Custom builder meta
const validate = meta((rule: string) => rule);

const userStore = store({
  name: "user",
  state: { name: "", password: "", token: "" },
  meta: [
    persist(),                                    // ✅ store-level (value: true)
    priority(1),                                  // ✅ store-level (value: 1)
    persist.for("name"),                          // ✅ single field (value: true)
    persist.for(["password", "token"]),           // ✅ multiple fields (value: true)
    validate.for(["email", "phone"], "required"), // ✅ multiple fields with value
  ],
});

// ❌ WRONG - don't pass field name as argument to flag meta
meta: [persist("password")]  // This passes "password" as VALUE, not field!
```

## Quick Patterns

### Define Store

```ts
const userStore = store({
  name: "user",
  state: { name: "", age: 0 },
  setup({ state, update }) {
    return {
      setName: (name: string) => {
        state.name = name;
      },
    };
  },
});
```

### Use in React

```tsx
function Component() {
  const { name, setName } = useStore(({ get }) => {
    const [state, actions] = get(userStore);
    return { name: state.name, setName: actions.setName };
  });
  return <input value={name} onChange={(e) => setName(e.target.value)} />;
}
```

### Component-Local Stores with scoped()

Use `scoped()` for stores that should be isolated to a component and auto-disposed on unmount:

```tsx
function FormComponent() {
  const { value, setValue } = useStore(({ get, scoped }) => {
    // Global stores via get()
    const [userState] = get(userStore);

    // Component-local stores via scoped() - auto-disposed on unmount
    const [formState, formActions, formInstance] = scoped(formStore);

    return {
      value: formState.value,
      setValue: formActions.setValue,
    };
  });

  return <input value={value} onChange={(e) => setValue(e.target.value)} />;
}
```

**Key points:**
- `scoped()` can only be called during selector execution (not in callbacks)
- Returns `[state, actions, instance]` tuple
- Each component gets its own isolated instance
- Instances are automatically disposed when component unmounts

### Async State

```ts
const userStore = store({
  name: "user",
  state: {
    user: async.fresh<User>(), // undefined during loading
    users: async.stale<User[]>([]), // keeps previous data
  },
  setup({ focus }) {
    const userAsync = async(focus("user"), async (ctx, id: string) => {
      const res = await fetch(`/api/users/${id}`, { signal: ctx.signal });
      return res.json();
    });
    return { fetchUser: userAsync.dispatch };
  },
});
```

### Trigger Fetch

```tsx
function UserProfile({ userId }: { userId: string }) {
  const { user } = useStore(({ get }) => {
    const [state, actions] = get(userStore);
    trigger(actions.fetchUser, [userId], userId);
    return { user: state.user };
  });

  if (user.status === "pending") return <Spinner />;
  if (user.status === "error") return <Error error={user.error} />;
  return <div>{user.data?.name}</div>;
}
```

## Common Errors

| Error                        | Cause                       | Solution                    |
| ---------------------------- | --------------------------- | --------------------------- |
| `Cannot wait: state is idle` | async.wait() on fresh idle  | Call trigger/dispatch first |
| `Setup phase has ended`      | get/mixin/focus in action   | Move to setup phase         |
| `Effect must be synchronous` | async effect                | Use ctx.safe()              |
| `lifetime mismatch`          | keepAlive → autoDispose dep | Fix dependency direction    |
| `scoped() outside selector`  | scoped() in callback/async  | Move to selector body       |

## Testing

- Use `jest` with `it()` (not `test()`)
- Write tests first, then code, then run and fix

## GitHub Pages Demo Deployment

When deploying demos (SPAs) alongside VitePress docs to GitHub Pages, follow these rules to avoid navigation issues between docs and demos:

### 1. Demo App: Handle Back Navigation

Each demo SPA must handle browser back/forward navigation outside its base path:

```tsx
// In demo's main.tsx
const BASE_PATH = "/storion/demos/my-demo";

// Handle back/forward navigation
window.addEventListener("popstate", () => {
  if (!window.location.pathname.startsWith(BASE_PATH)) {
    // Navigated outside demo - do full page reload
    window.location.reload();
  }
});
```

### 2. Demo App: Vite Base Path

Configure Vite with the correct base path:

```ts
// vite.config.ts
export default defineConfig({
  base: "/storion/demos/my-demo/",
  // ...
});
```

### 3. Docs: Force Full Navigation to Demos

In VitePress, demo links must trigger full page navigation (not client-side routing):

```vue
<!-- In demos.md -->
<script setup>
import { onMounted } from 'vue'

onMounted(() => {
  document.querySelectorAll('a[href*="/demos/"]').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault()
      window.location.href = link.getAttribute('href')
    })
  })
})
</script>
```

### 4. GitHub Actions: Add .nojekyll

Prevent Jekyll processing of the static site:

```yaml
# In .github/workflows/docs.yml
- name: Add .nojekyll file
  run: touch packages/docs/.vitepress/dist/.nojekyll
```

### 5. Demo Build Output

All demo builds should be copied to `packages/docs/.vitepress/dist/demos/`:

```yaml
# In .github/workflows/docs.yml
- name: Copy demo builds
  run: |
    mkdir -p packages/docs/.vitepress/dist/demos
    cp -r packages/my-demo/dist packages/docs/.vitepress/dist/demos/my-demo
```

### Why These Rules?

| Issue | Cause | Solution |
|-------|-------|----------|
| Back button doesn't work | Demo SPA captures all routes | `popstate` listener with reload |
| Demo doesn't load on click | VitePress client-side routing | Force `window.location.href` |
| 404 on refresh | GitHub Pages tries Jekyll | Add `.nojekyll` file |
| Styles broken | Wrong asset paths | Correct Vite `base` path |
